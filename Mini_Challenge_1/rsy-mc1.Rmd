---
title: "RSY-MC1"
author: "Patrick, Ben"
output: 
  html_notebook:
    toc: True
    toc_float: True
---
# Mini-Challenge Beschreibung


# Daten und Libraries
```{r}
library(tidyverse)
library(recommenderlab)
```
## Daten einlesen
```{r}
data(MovieLense)
```

## Library Methoden zum Datensatz MovieLense
```{r}
methods(class = class(MovieLense))
```

## Kopfzeilen vom Datensatz ausgeben
```{r}
head(as(MovieLense, "data.frame"))
```

## Fusszeilen vom Datensatz ausgeben
```{r}
tail(as(MovieLense, "data.frame"))
```

## Info zum Datensatz
```{r}
summary(as(MovieLense, "data.frame"))
```
## Datenframe Variabel erstellen
```{r}
MovieLenseEDA <- as(MovieLense, "data.frame")
```


# Explorative Datenanalyse
Aufgabe 1: Untersuche den vollständigen MovieLense Datensatz 
(d.h. vor Datenreduktion!) und beantworte folgende Fragen

## 1. Welches sind die am häufigsten geschauten Genres/Filme?

### Filme
```{r}
MovieLenseEDA %>% 
  group_by(item) %>% 
  summarise(Anzahl = n()) %>%
  arrange(desc(Anzahl)) 
```

### Genre
```{r}
# Full Join mit df_movies_rating und MovieLenseMeta
MovieLenseEDA_Joined <- full_join(MovieLenseEDA, MovieLenseMeta, 
          by = c("item" = "title")) %>% 
  select(-c("user", "item", "rating", "year", "url")) 

# Aufsummieren der Genre Spalten
(colSums(MovieLenseEDA_Joined)) %>% sort(decreasing = TRUE)

### 
# Muessen wir Genre Unknown entfernen?
```

## 2. Wie verteilen sich die Kundenratings gesamthaft und nach Genres?
```{r}
# DataFrame join
MovieLenseEDA_Joined <- full_join(MovieLenseEDA, MovieLenseMeta, 
          by = c("item" = "title"))
```

### Verteilung der Kundenratings Gesamthaft
```{r}
MovieLenseEDA_Joined$rating <- as.factor(MovieLenseEDA_Joined$rating)

MovieLenseEDA_Joined %>% group_by(rating) %>%
  summarize(Anzahl = n()) %>% 
  ggplot(aes(x = rating, y = Anzahl)) + 
  geom_bar(stat = "identity", 
           fill = "lightblue", 
           color = "black") + 
  labs(x = "Ratings", 
       y = "Anzahl", 
       title = "Kundenratings Gesamthaft",
       subtitle = "MovieLenseData")
```

### Verteilung der Kundenratings nach Genre
```{r}
# DataFrame reshape 
MovieLenseEDA_Joined$rating <- as.integer(MovieLenseEDA_Joined$rating)

MovieLenseEDA_Joined %>% 
  select(-c("item", "user", "year", "url")) %>% 
  pivot_longer(cols=c("unknown", "Action", "Adventure", "Animation", "Children's",
                      "Comedy", "Crime", "Documentary", "Drama", "Fantasy",
                      "Film-Noir", "Horror", "Musical", "Mystery", "Horror",
                      "Musical", "Mystery", "Romance", "Sci-Fi", "Thriller",
                      "War", "Western"),
               names_to = "Genre", values_to = "X") %>% 
  ggplot(aes(x = rating)) +
  geom_bar(fill = "lightblue", color = "black") + 
  facet_wrap(~Genre)

# Alle Plots sehen identisch aus? 
  
```

```{r}


MovieLenseHistoGenreRating <- MovieLenseEDA_Joined %>% 
  select(-c("item", "user", "year", "url")) %>% 
  pivot_longer(cols=c("unknown", "Action", "Adventure", "Animation", "Children's",
                      "Comedy", "Crime", "Documentary", "Drama", "Fantasy",
                      "Film-Noir", "Horror", "Musical", "Mystery", "Horror",
                      "Musical", "Mystery", "Romance", "Sci-Fi", "Thriller",
                      "War", "Western"),
               names_to = "Genre", values_to = "X") %>%
  group_by(Genre, rating) %>%
  summarize(Anzahl = n()) 
  
MovieLenseHistoGenreRating$rating <- as.factor(MovieLenseHistoGenreRating$rating)

MovieLenseHistoGenreRating 
# ToDO Vis fehlt
```


## 3. Wie verteilen sich die mittleren Kundenratings pro Film?
```{r}
MovieLenseEDA %>% 
  group_by(item) %>% 
  summarize(mean_rating_per_film = mean(rating)) %>% 
  ggplot(aes(x = mean_rating_per_film)) + 
  geom_histogram(color = "black", fill = "lightblue", binwidth = 0.5) +
    labs(x = "Ratings", 
       y = "Anzahl", 
       title = "Mittlere Kundenratings verteilung",
       subtitle = "MovieLenseData")

```

## 4. Wie stark streuen die Ratings von individuellen Kunden?
```{r}
MovieLenseEDA %>% filter(user == c(1:9)) %>% 
  ggplot(aes(x = user, y = rating)) +
  geom_violin(color = "black", fill = "lightblue") 

# Beschriftung und Farbe
```

## 5. Welchen Einfluss hat die Normierung der Ratings pro Kunde auf deren Verteilung?
```{r}
MovieLensenormalized <- normalize(MovieLense)
MovieLenseEDA_Normalized <- (as(MovieLensenormalized, "data.frame"))

MovieLenseEDA_Normalized %>% filter(user == c(1:9)) %>% 
  ggplot(aes(x = user, y = rating)) +
  geom_violin(color = "black", fill = "lightblue") 

# Labelings & Interpreation

```

## 6. Welche strukturellen Charakteristika (z.B. Sparsity) und Auffälligkeiten zeigt die User-Item Matrix?
```{r}
image(MovieLense) 

# Labeling + Interpreation + Antwort fehlt. 
# Aufsteigend nach Anzahl bewertete Filmen
# Film Besonders die ersten 400 Filme wurden am meisten bewrtet.
# User kein Muster erkennbar
```

```{r}
# nratings => Gibt mir die Anzahl Bewerteten Filme in der Matrix
# dim(MovieLense) gibt mir die Dimension (Zeilen, Spalten)

nratings(MovieLense) / (dim(MovieLense)[1] * dim(MovieLense)[2]) * 100
```

# Datenreduktion
## Aufgabe 2: Reduziere den MovieLense Datensatz auf rund 400 Kunden und 700 Filme, indem du Filme und Kunden mit sehr wenigen Ratings entfernst.

### DataFrame neu einlesen
```{r}
MovieLenseToCut <- as(MovieLense, "data.frame")
```

### Auswahl der 400 Kunden
```{r}
MovieLense400User <- MovieLenseToCut %>% 
  group_by(user) %>% 
  summarize(Anzahl = n()) %>% 
  arrange(desc(Anzahl)) %>% 
  slice(0:400)
head(MovieLense400User)
```

### Auswahl der 700 Movies
```{r}
MovieLense700Items <- MovieLenseToCut %>% 
  group_by(item) %>% 
  summarise(Anzahl = n()) %>% 
  arrange(desc(Anzahl)) %>% 
  slice(0:700)
head(MovieLense700Items)
```

### DataFrame schneiden
```{r}
MovieLenseCut <- MovieLenseToCut %>% 
  filter(user %in% c(MovieLense400User$user))

MovieLenseCut <- MovieLenseCut %>% 
  filter(item %in% c(MovieLense700Items$item))


```

Untersuche und dokumentiere die Eigenschaften des reduzierten Datensatzes und beschreibe den Effekt der Datenreduktion, d.h.

## 1. Anzahl Filme und Kunden sowie Sparsity vor und nach Datenreduktion,

### Vor der Datenreduktion
```{r}
image(MovieLense)
```

```{r}
nratings(MovieLense) / (dim(MovieLense)[1] * dim(MovieLense)[2]) * 100

```


### Nach Datenreduktion
```{r}
MovieLenseCompact <- as(MovieLenseCut, "realRatingMatrix")
image(MovieLenseCompact)
```

### Vergleich der Sparsity
```{r}
nratings(MovieLenseCompact) / (dim(MovieLenseCompact)[1] * dim(MovieLenseCompact)[2]) * 100

# Interpreation
```

##2. Mittlere Kundenratings pro Film vor und nach Datenreduktion,

```{r}
MovieLenseCut %>% 
  group_by(item) %>% 
  summarize(mean_rating_per_film = mean(rating)) %>% 
  ggplot(aes(x = mean_rating_per_film)) + 
  geom_histogram(color = "black", fill = "lightblue", binwidth = 0.5) +
    labs(x = "Ratings", 
       y = "Anzahl", 
       title = "Mittlere Kundenratings verteilung",
       subtitle = "MovieLenseData")
  
# Willst du eine Verteilung fuer jeden Film oder reicht dir eine Tabelle?

```

## 3. Für Gruppen: Quantifiziere “Intersection over Union” der Ratings der unterschiedlich reduzierten Datensätze.

```{r}
# Fragezeichen? 

```

# Analyse Ähnlichkeitsmatrix

## Aufgabe 3: Erzeuge einen IBCF Recommender und analysiere die Ähnlichkeitsmatrix des trainierten Modelles für den reduzierten Datensatz.

## 1. Zerlege den reduzierten MovieLense Datensatz in ein disjunktes Trainings-und Testdatenset im Verhältnis 4:1,

```{r}
training <- MovieLenseCompact[1:320] 
test <- MovieLenseCompact[321:400]

training
test
```

## 2. Trainiere ein IBCF Modell mit 30 Nachbarn und Cosine Similarity

```{r}
ribcf <- Recommender(training, "IBCF", param=list(k= 30, method = "cosine"))
ribcf
```

## 3. Bestimme die Verteilung der Filme, welche bei IBCF für paarweise Ähnlichkeitsvergleiche verwendet werden,

```{r}
names(getModel(ribcf))
```

```{r}
getModel(ribcf)$topN

# ??? 
```


##4. Bestimme die Filme, die am häufigsten in der Cosine-Ähnlichkeitsmatrix auftauchen und analysiere deren Vorkommen und Ratings im reduzierten Datensatz.

```{r}
"ribcftopNList <- as(ribcftopNList, "list")
ribcftopNList <- combine(ribcftopNList)
ribcftopNList <- data.frame(ribcftopNList)
ribcftopNList <- ribcftopNList %>% group_by(ribcftopNList) %>% summarise(Anzahl = n()) %>% arrange(desc(Anzahl))
ribcftopNList"""

#??? 
```




# Implementierung Ähnlichkeitsmatrix
Aufgabe 4 (DIY): Implementiere eine Funktion zur effizienten
Berechnung von sparsen Ähnlichkeitsmatrizen für IBCF RS und
analysiere die Resultate für 100 zufällig gewählte Filme.



## 1. Implementiere eine Funktion, um (a) für ordinale Ratings effizient
die Cosine Similarity und (b) für binäre Ratings effizient die Jaccard
Similarity zu berechnen,

```{r}
as(MovieLenseCompact, "data.frame")
```


### Cosine Similarity 
```{r}
"cosin_sim <- t(MovieLenseCompact) / sqrt(rowSums(t(MovieLenseCompact) * t(MovieLenseCompact)))
                                   
cosin_sim_mat <- cosin_sim %*% t(cosin_sim)"""
```

### Jaccard Similarity
```{r}

```



## 2. Vergleiche deine Implementierung der Cosine-basierten
Ähnlichkeitsmatrix für ordinale Ratings mit der via recommenderlab
und einem anderen R-Paket erzeugten Ähnlichkeitsmatrix,

```{r}

```

##3. Vergleiche deine mittels Cosine Similarity erzeugten Ähnlichkeitsmatrix für ordinale Ratings mit der Jaccard-basierten
Ähnlichkeitsmatrix für binäre Ratings.

```{r}

```


# Analyse Top-N Listen - IBCF vs UBCF
Aufgabe 5: Vergleiche und diskutiere Top-N Empfehlungen von IBCF
und UBCF Modellen mit 30 Nachbarn und Cosine Similarity für den
reduzierten Datensatz.

## 1. Berechne Top-15 Empfehlungen für Testkunden mit IBCF und UBCF 

### ribcf & rubcf Modell trainieren
```{r}
ribcf <- Recommender(training, "IBCF", param=list(k= 30, method = "cosine"))
ribcf
rubcf <- Recommender(training, "UBCF", param=list(nn= 30, method = "cosine"))
rubcf
```
### Model Predicitions erstellen
```{r}
ribcftopNList = predict(ribcf, test, n=15)
ribcftopNList

rubcftopNList = predict(rubcf, test, n=15)
rubcftopNList
```

### ## 2. Vergleiche die Top-15 Empfehlungen und deren Verteilung und
diskutiere Gemeinsamkeiten und Unterschiede zwischen IBCF und
UBCF für alle Testkunden.

```{r}
ribcftopNList <- as(ribcftopNList, "list")
ribcftopNList <- combine(ribcftopNList)
ribcftopNList <- data.frame(ribcftopNList)

ribcftopNList <- ribcftopNList %>%
  group_by(ribcftopNList) %>%
  summarise(Anzahl = n()) %>%
  arrange(desc(Anzahl))
ribcftopNList


rubcftopNList <- as(rubcftopNList, "list")
rubcftopNList <- combine(rubcftopNList)
rubcftopNList <- data.frame(rubcftopNList)

rubcftopNList <- rubcftopNList %>%
  group_by(rubcftopNList) %>%
  summarise(Anzahl = n()) %>%
  arrange(desc(Anzahl))

rubcftopNList
```

### Verteilungen visualisieren
```{r}
ribcftopNList %>% 
  ggplot(aes(x = Anzahl)) + 
  geom_histogram(fill = "lightblue", color = "black") +
  labs(title = "Verteilung der Anzahl Empfehlungen rbcif")
```


Hinweis: betrachte die Verteilung der Top-15 Empfehlungen und
beleuchte die pauschale Behauptung “Recommender Systeme machen
für alle Nutzer die gleichen Empfehlungen”.
```{r}

```



