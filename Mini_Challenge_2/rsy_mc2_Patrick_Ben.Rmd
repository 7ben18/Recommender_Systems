---
title: "RSY-MC2"
author: "Patrick, Ben"
output: 
  html_notebook:
    toc: True
    toc_float: True
---

# Settings
```{r}
library(tidyverse)
library(recommenderlab)
```


# 1. Erzeugung von Film- & Nutzerprofilen

## 1.1 MovieLense Daten einlesen

```{r}
data(MovieLense)
```

## 1.2 Binäre User-Liked-Items Matrix für alle Nutzer erzeugen.

```{r}
as(MovieLense[1:4, 1:4], "matrix")

user_liked_items_binaer <- binarize(MovieLense, minRating = 4)

as(user_liked_items_binaer[1:4, 1:4], "matrix")
```

## 1.3 Dimension der User-Liked-Items Matrix prüfen und ausgeben.

```{r}
dim(user_liked_items_binaer)
```
Die User-Liked-Items Matrix hat eine Dimension von 943 User und 1664 Items (Movies). 

## 1.4 Movie-Genre Matrix für alle Filme erzeugen.

```{r}
Movie_Genre_df <- MovieLenseMeta %>% select(-c(year, url))

Movie_genre_matrix <- as(Movie_Genre_df, "matrix")

Movie_genre_matrix[1:5, 1:6]
```

## 1.5 Dimension der Movie-Genre Matrix prüfen und ausgeben.

```{r}
dim(Movie_genre_matrix)
```
Die Movie_genre_Matrix hat eine Dimension von 1664 User und 20 Genre. 

## 1.6 Anzahl unterschiedlicher Filmprofile bestimmen und visualisieren.

```{r}
Movie_genre_matrix_renamed <- Movie_genre_matrix

colnames <- colnames(Movie_genre_matrix)[-1]

for (colname in colnames) {
  Movie_genre_matrix_renamed[, colname] <- ifelse(Movie_genre_matrix[, colname] == 1, colname, NA)
}

Movie_genre_renamed_df <- as.data.frame(Movie_genre_matrix_renamed)

rownames(Movie_genre_renamed_df) <- Movie_genre_renamed_df[, 1]

Movie_genre_renamed_df <- Movie_genre_renamed_df %>% select(-c(title))

Movie_genre_concat_df <- Movie_genre_renamed_df %>% unite("profile", sep = "-", na.rm = TRUE, remove = TRUE)

Movie_genre_concat_df 

Movie_genre_concat_df %>% group_by(profile) %>% summarise(Anzahl = n()) %>% arrange(desc(Anzahl)) %>% head(30) %>% arrange(profile) %>% 
ggplot(aes(x = Anzahl, y = profile, fill = "red")) + 
  ggtitle("Anzahl unterschiedlicher Filmprofile") +
  geom_bar(stat = "identity") + 
  theme(legend.position="none")

```

## 1.7 Nutzerprofile im Genre-Vektorraum erzeugen.

```{r}

user_rating_df <- as(MovieLense, "data.frame")

user_rating_genre_df <- left_join(user_rating_df, Movie_Genre_df, by = c("item" = "title"))

user_rating_genre_df

```

```{r}
multiplied_rating_genre <- cbind(user_rating_genre_df$user, sapply(user_rating_genre_df[4:22], "*", user_rating_genre_df$rating))
```


```{r}
multiplied_rating_genre_df <- as.data.frame(multiplied_rating_genre) %>% rename(user = V1)

multiplied_rating_genre_df
```


```{r}
# change every column except first one to int
for (colname in colnames(multiplied_rating_genre_df)[-1]) {
  multiplied_rating_genre_df[, colname] <- as.integer(multiplied_rating_genre_df[, colname])
}

# replace all 0 with NA
#multiplied_rating_genre_df[multiplied_rating_genre_df == 0] <- NA

# groupby user and calculate mean of every column 
user_genre_profile_df <- multiplied_rating_genre_df %>% group_by(user) %>% summarise_all(mean, na.rm = TRUE) %>% arrange(user) %>% column_to_rownames(., var = "user")

user_genre_profile_df

```



## 1.8 Dimension der User-Genre-Profil Matrix prüfen und ausgeben.

```{r}
dim(user_genre_profile_df)
```
Wie zu erwarten haben wir weiterhin 943 User und 19 Genre. 


## 1.9 Anzahl unterschiedlicher Nutzerprofile bestimmen, wenn Stärke der

Genre-Kombination (a) vollständig (b) binär berücksichtigt wird.

```{r}
# Schauen ob doppelte Werte vorhanden sind und zaehlen. (a)
# Alle Werte >0 als 1 deklarieren und anschliessend schauen, ob doppelte Werte vorhanden sind im Df und diese Zaehlen,
# Anzahl beider (a) und (b) vergleichen und beschreiben wie viele gleiche User man hat. 
```

# 2. Ähnlichkeit von Nutzern und Filmen

## 2.1 Cosinus-Ähnlichkeit zwischen User-Genre- und Movie-Genre-Matrix berechnen.

```{r}
head(user_genre_profile_df, n = 3)

# remove first col in Movie_Genre_df
movie_genre_df <- Movie_Genre_df %>% 
  select(c(-1)) 

head(movie_genre_df, n = 3)

# turn both dataframe into a r matrix
user_genre_matrix <- as.matrix(user_genre_profile_df)
movie_genre_matrix <- as.matrix(movie_genre_df)

# create small testing matrices
test_user_genre_matrix <- user_genre_matrix[1:5, 1:5]
test_user_genre_matrix

test_movie_genre_matrix <- movie_genre_matrix[1:5, 1:5]
test_movie_genre_matrix

```

```{r}

z_test = test_user_genre_matrix %*% t(test_movie_genre_matrix)
z_test

user_genre_rowsums <- sqrt(rowSums(test_user_genre_matrix**2))
movie_genre_rowsums <- sqrt(rowSums(test_movie_genre_matrix**2))

user_genre_rowsums 
movie_genre_rowsums

n_test = user_genre_rowsums %*% t(movie_genre_rowsums)
n_test

z_test / n_test
```



```{r}
cosine_sim_func <- function(user_genre_matrix, movie_genre_matrix){
  # matrix multiplication of user_genre_matrix @ movie_genre_matrix.T
  # User Movie Matrix: A x B.T
  zaehler = user_genre_matrix %*% t(movie_genre_matrix)
  
  # calculating the sqrt(sum(x^2, row matrix)) of each matrix and get a vector
  user_genre_sqrt_rowsum_x2 <- sqrt(rowSums(user_genre_matrix ** 2))
  movie_genre_sqrt_rowsum_x2 <- sqrt(rowSums(movie_genre_matrix ** 2))
  
  # now we create a matrix out of those two vectors
  # User Movie Matrix: ||A|| x ||B||.T
  nenner = user_genre_sqrt_rowsum_x2 %*% t(movie_genre_sqrt_rowsum_x2)
  
  # calculate Cosine similarity
  user_movie_cosine_sim_matrix = zaehler / nenner
  
  user_movie_cosine_sim_matrix 
}

cosine_sim_func(test_user_genre_matrix, test_movie_genre_matrix)
```

```{r}
cosine_sim_matrix <- cosine_sim_func(user_genre_matrix, movie_genre_matrix)
View(cosine_sim_matrix)
```


## 2.2 Dimension der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen prüfen und ausgeben.

```{r}
dim(cosine_sim_matrix)
```

## 2.3 5-Zahlen Statistik für Matrix der Cosinus-Ähnlichkeiten prüfen und ausgeben.

```{r}
cosine_sim_vector <- as.vector(cosine_sim_matrix)

summary(cosine_sim_vector)
```

## 2.4 Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot visualisieren.

```{r}
cosine_sim_vector_density <- density(cosine_sim_vector)

plot(cosine_sim_vector_density, lwd = 2, col = "red",
     main = "Density")
```

## 2.5 Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot für

Nutzer "241", "414", "477", "526", "640" und "710" visualisieren.


```{r}
cosine_sim_matrix_user <- cosine_sim_matrix[c(241, 414, 477, 526, 640, 710),]

df_cosine_sim_matrix <- as.data.frame(cosine_sim_matrix_user)

df_cosine_sim_matrix

df_cosine_sim_matrix <- df_cosine_sim_matrix %>% 
  rownames_to_column("user_id")

df_cosine_sim_matrix_long <- df_cosine_sim_matrix %>% 
  gather(genre, cosine_sim, -user_id)

df_cosine_sim_matrix_long

ggplot(df_cosine_sim_matrix_long, aes(x = cosine_sim, fill = user_id)) +
  geom_density(alpha = 0.1) +
  labs(title = "Dichteplot von verschiedenen User",
       x = "Cosine Similarity",
       y = "Density")

ggplot(df_cosine_sim_matrix_long, aes(x = cosine_sim)) + 
  geom_density(color = "red") + 
  facet_wrap(~ user_id)
```


# 3. Empfehlbare Filme

## 3.1 Bewertete Filme maskieren, d.h. "Negativabzug" der User-Items Matrix erzeugen, um anschliessend Empfehlungen herzuleiten.

```{r}
movielense <- as(MovieLense,'matrix')

movielense[1:5,1:4]

movielense[!is.na(movielense)] <- 0
movielense[is.na(movielense)] <- 1

movielense[1:5,1:4]
```

## 3.2 Zeilensumme des "Negativabzuges" der User-Items Matrix für die

User "5", "25", "50" und "150" ausgeben.

```{r}
movielense[1:5, 1:4]
```


```{r}
user_list = c(5,25,50,150)

# select the rows of the user_list
movielense_user_list <- movielense[user_list,]
movielense_user_list[1:4,2:5]

dim(movielense_user_list)
# sum the rows
movielense_user_list_rowsum <- rowSums(movielense_user_list)

movielense_user_list_rowsum

```
User 150 hat 1633 Items nicht bewertet.
Im genrellen haben alle 4 ausgewaehlten User sehr wenig Filme bewertet. 
User 5 hat am meisten Filme bewertet. (1664 - 1489) Bewertungen hat der User 5 gemacht. 


## 3.3 5-Zahlen Statistik der Zeilensumme des "Negativabzuges" der UserItems Matrix bestimmen.

```{r}
movielense_user_list_df <- as.data.frame(movielense_user_list) %>% 
  rownames_to_column("user_id") 
movielense_user_list_df

movielense_user_list_df_long <- movielense_user_list_df %>% 
  pivot_longer(cols = -user_id, names_to = "movie_id", values_to = "rating")

movielense_user_list_df_long

movielense_user_list_df_long %>% 
  group_by(user_id) %>% 
  summarise(min = min(rating), 
            quantile_1 = quantile(rating, 0.25), 
            median = median(rating), 
            #mean = mean(rating), 
            quantile_3 = quantile(rating, 0.75), 
            max = max(rating)) %>% 
  arrange(user_id)

```

# 4. Top-N Empfehlungen

## 4.1 Matrix für Bewertung aller Filme durch element-weise

Multiplikation der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen und "Negativabzug" der User-Items Matrix erzeugen.

```{r}
cosine_sim_matrix[1:3,1:6]

movielense[1:5,1:4]

dim(cosine_sim_matrix)

dim(movielense)

movie_rating_matrix <- movielense * cosine_sim_matrix

movie_rating_matrix[1:3, 1:4]
```

## 4.2 Dimension der Matrix für die Bewertung aller Filme prüfen.

```{r}
dim(movie_rating_matrix)
```

## 4.3 Top-20 Listen extrahieren und Länge der Listen pro Nutzer prüfen.

```{r}
# check num of user we have in our matrix
number_of_user <- dim(movie_rating_matrix)[1]
# check num of movies we have in our matrix
number_of_movies <- dim(movie_rating_matrix)[2]

# create a list of top20 items for each user (list in a list)
top_20_movies_user <- list()

# this is sorting the top20 movies from user 5 (need to use that)
sort(movie_rating_matrix[5, ], decreasing = TRUE)[1:20]

# add to index 5 for user 5
top_20_movies_user[[5]] <- sort(movie_rating_matrix[5, ], decreasing = TRUE)[1:10]

# okay... we need a function wit a for loop
# Loop through each user
for (user in 1:number_of_user){
  top_20_movies_user[[user]] <- sort(movie_rating_matrix[user, ], decreasing=TRUE)[1:20]
}

# check length
length(top_20_movies_user[[5]])

```

```{r}
# liste ausgeben
top_20_movies_user[c(5,718)]
```

```{r}
get_topn_recos <- function(rating_matrix, N) {
  number_of_user <- dim(rating_matrix)[1]
  number_of_movies <- dim(rating_matrix)[2]

  top_N_list <- list()

  for (user in 1:number_of_user) {
    top_N_list[[user]] <- sort(rating_matrix[user, ], decreasing=TRUE)[1:N]
  }

  return(top_N_list)
}

# get top-N fuer User 5 und 718
top_20_list_all_user <- get_topn_recos(movie_rating_matrix, 20)

# get from User 5 and 718 top_20
top_20_list_all_user[c(5, 718)]
```

```{r}
# check length for every user
summary(lengths(top_20_list_all_user))
```



## 4.4 Verteilung der minimalen Ähnlichkeit für Top-N Listen für N = 10, 20, 50, 100 für alle Nutzer visuell vergleichen.

```{r}
# testing
top_10_list <- get_topn_recos(movie_rating_matrix, 10)

# create a empty vector 
top_10_vec <- c()

# loop through each user
for (user in 1:length(top_10_list)) {
  top_10_vec <- c(top_10_vec, as.numeric(min(top_10_list[[user]])))
}

# create now a density plot with ggplot 
ggplot(data.frame(top_10_vec), aes(x = top_10_vec)) + 
  geom_density(fill = "blue", alpha = 0.5) + 
  labs(title = "Density Plot for Top 10 List", 
       x = "Similarity", 
       y = "Density")
```

```{r}
# function for density plot
analyze_topn_recos <- function(rating_matrix, N) {
  top_N_list <- get_topn_recos(rating_matrix, N)
  top_N_vec <- c()

  for (user in 1:length(top_N_list)) {
    top_N_vec <- c(top_N_vec, as.numeric(min(top_N_list[[user]])))
  }

  ggplot(data.frame(top_N_vec), aes(x = top_N_vec)) + 
    geom_density(fill = "blue", alpha = 0.5) + 
    labs(title = paste("Verteilung der Top-N Empfehlung fuer alle User: N =", N, "List"), 
         x = "Similarity", 
         y = "Density")
}

analyze_topn_recos(movie_rating_matrix, 10)

```

```{r}
top_N_movies <- c(10,20,50,100)

for (N in top_N_movies) {
  print(analyze_topn_recos(movie_rating_matrix, N))
}

```

## 4.5 Top-20 Empfehlungen für Nutzer "5", "25", "50", "150" visualisieren.

```{r}
# testing
top_45_list <- get_topn_recos(movie_rating_matrix, 20)[c(5,25,50,150)]

top_45_list

movies_45_user5 <- names(top_45_list[[1]])
sim_45_user5 <- as.numeric(top_45_list[[1]])

# create a data frame
df_45_user5 <- data.frame(movies_45_user5, sim_45_user5)

df_45_user5

# cleveland plot
ggplot(df_45_user5, aes(x = sim_45_user5, y = movies_45_user5)) + 
  geom_point()

# create a barplot with ggplot and rotate x-axis
ggplot(df_45_user5, aes(x = reorder(movies_45_user5, sim_45_user5), y = sim_45_user5)) + 
  geom_bar(stat = "identity", fill = "blue", alpha = 0.5) + 
  labs(title = "Top 20 Empfehlungen fuer User 5", 
       x = "Movie", 
       y = "Similarity") + 
  coord_flip()
```





```{r}
create_cleveland_plot <- function(rating_matrix, N, user) {
  top_N_list <- get_topn_recos(rating_matrix, N)
  top_N_user <- top_N_list[[user]]

  movies_N_user <- names(top_N_user)
  sim_N_user <- as.numeric(top_N_user)

  df_N_user <- data.frame(movies_N_user, sim_N_user)
  
  # cleveland plot
  ggplot(df_N_user, aes(x = sim_N_user, y = movies_N_user)) + 
    geom_point() + 
    labs(title = paste("Top", N, "Empfehlungen fuer User", user), 
    x = "Movie", 
    y = "Similarity")
}

users <- c(5, 25, 50, 150)

for (u in users){
  print(create_cleveland_plot(movie_rating_matrix, 20, u))
}

```

## 4.6 Für Nutzer "133" und "555" Profil mit Top-N Empfehlungen für N = 20, 30, 40, 50 analysieren, visualisieren und diskutieren.

```{r, fig.width=6, fig.height=4}

N_list_46 <- c(20,30,40,50)
N_user_46 <- c(133, 555)

create_cleveland_plot(movie_rating_matrix, 20, 133)

for (N in N_list_46) {
  for (user in N_user_46) {
    print(create_cleveland_plot(movie_rating_matrix, N, user))
  }
}
```
